import 'package:drift/drift.dart';
import 'package:flutter/material.dart' hide Theme;
import 'package:selene/core/database/database.dart';
import 'package:selene/core/database/tables/themes_table.dart';
import 'package:selene/core/theme/models/app_theme.dart';
import 'package:selene/core/theme/data/predefined_themes.dart';

part 'themes_dao.g.dart';

@DriftAccessor(tables: [Themes])
class ThemesDao extends DatabaseAccessor<AppDatabase> with _$ThemesDaoMixin {
  ThemesDao(super.db);

  // --- Read Operations ---

  /// Get all themes
  ///
  /// Returns a list of all themes in the database.
  Stream<List<AppTheme>> watchAllThemes() {
    return select(themes).watch().map((rows) {
      // Map Drift rows to Freezed AppTheme objects
      return rows.map((row) => _convertThemeToModel(row)).toList();
    });
  }

  /// Gets a single theme by its ID.
  Future<AppTheme?> getThemeById(String id) async {
    final row =
        await (select(themes)
          ..where((tbl) => tbl.id.equals(id))).getSingleOrNull();
    return row != null ? _convertThemeToModel(row) : null;
  }

  Stream<AppTheme?> watchThemeById(String id) {
    return (select(themes)
      ..where((tbl) => tbl.id.equals(id))).watchSingleOrNull().map(
      (row) => row != null ? _convertThemeToModel(row) : null,
    );
  }

  // --- Write Operations ---

  /// Inserts or updates a theme based on its ID.
  Future<void> upsertTheme(AppTheme theme) {
    // Convert Freezed AppTheme to Drift Companion object
    final companion = _convertThemeToDB(theme);
    return into(themes).insertOnConflictUpdate(companion);
  }

  /// Deletes a theme by ID. Consider adding checks to prevent deleting system themes.
  Future<int> deleteTheme(String id) {
    // Optional: Check if it's a system theme before deleting
    // final themeData = await getThemeById(id);
    // if (themeData != null && themeData.isSystem) {
    //   throw Exception("Cannot delete system theme '$id'");
    // }
    return (delete(themes)..where((tbl) => tbl.id.equals(id))).go();
  }

  /// Converts a Drift row (`Theme` data class generated by Drift) to a Freezed `AppTheme`.
  AppTheme _convertThemeToModel(Theme row) {
    return AppTheme(
      id: row.id,
      name: row.name,
      category: row.category,
      primary: row.primary,
      secondary: row.secondary,
      tertiary: row.tertiary,
      error: row.error,
      neutral: row.neutral,
      neutralVariant: row.neutralVariant,
      variant: row.variant,
      isPrebuilt: row.isPrebuilt,
      isEditable: row.isEditable,
    );
  }

  /// Converts a Freezed `AppTheme` to a Drift `ThemesCompanion` for inserts/updates.
  ThemesCompanion _convertThemeToDB(AppTheme theme) {
    return ThemesCompanion(
      id: Value(theme.id),
      name: Value(theme.name),
      category: Value(theme.category),
      primary: Value(theme.primary),
      secondary: Value(theme.secondary),
      tertiary: Value(theme.tertiary),
      error: Value(theme.error),
      neutral: Value(theme.neutral),
      neutralVariant: Value(theme.neutralVariant),
      variant: Value(theme.variant),
      isPrebuilt: Value(theme.isPrebuilt),
      isEditable: Value(theme.isEditable),
    );
  }

  // --- Initialization (Optional) ---

  /// Ensures default system themes exist in the database on first launch.
  /// Call this when the database is first created or opened.
  Future<void> ensureDefaultThemes({Color? dynamicColor}) async {
    // final lightExists = await getThemeById(systemLightTheme.id);
    // if (lightExists == null) {
    //   await upsertTheme(systemLightTheme);
    // }
    // final darkExists = await getThemeById(systemDarkTheme.id);
    // if (darkExists == null) {
    //   await upsertTheme(systemDarkTheme);
    // }
    // Iterate through themes map and add all themes
    for (final theme in predefinedThemes.values) {
      final exists = await getThemeById(theme.id);
      if (exists == null) {
        await upsertTheme(theme);
      }
    }
    // Upsert dynamic color theme
    if (dynamicColor != null) {
      final dynamicTheme = AppTheme(
        id: 'dynamic',
        name: 'Dynamic',
        category: ThemeCategory.system,
        primary: dynamicColor,
        isPrebuilt: true,
        isEditable: false,
      );
      await upsertTheme(dynamicTheme);
    }
  }
}
